#!/usr/bin/env bash
######################################################################
#
# image.sh
#
# Image a disk, given an image (.wic).
#
######################################################################

# Export everything
set -a

# Version
VERSION=__VERSION__

# Name
SCRIPT_NAME=$(basename "${0}")

# Script directory
SCRIPT_DIR=`dirname $0`
pushd ${SCRIPT_DIR} >/dev/null 2>&1
SCRIPT_DIR=$(pwd)
popd >/dev/null 2>&1

#############
# Functions #
#############

function getdv {
    if [ -f /etc/os-release ]; then
	# freedesktop.org and systemd
	. /etc/os-release
	DISTRO=$NAME
	VER=$VERSION_ID
    elif type lsb_release >/dev/null 2>&1; then
	# linuxbase.org
	DISTRO=$(lsb_release -si)
	VER=$(lsb_release -sr)
    else
	# Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
	DISTRO=$(uname -s)
	VER=$(uname -r)
    fi

    echo "$DISTRO:$VER"
}

function script_info {
    echo "--> ${SCRIPT_NAME} version is ${VERSION}"
    echo "--> running on $(getdv)"
}

function unuse_disk {
    DISK=$1

    while read l
    do
	if [[ $l ]]
	then
	    P=$(echo $l | cut -d' ' -f 1)
	    MP=$(echo $l | cut -d' ' -f 3)
	    echo "$P is mounted as $MP, unmounting."
	    umount $MP

	    if [ $? -ne 0 ]
	    then
		echo "umount $MP failed!"
		exit 1
	    fi
	fi
    done <<< $(mount | grep $DISK)

    while read l
    do
	if [[ $l ]]
	then
	    P=$(echo $l | cut -d' ' -f1)
	    echo "$P is used as swap, turning it off."
	    swapoff $P
	fi
    done <<< $(swapon -s | egrep $DISK)
}

############
# Defaults #
############

DISK=""
LOC=""
GUDV=""
IMAGE=""
KEEP_TEMP="false"

######################################################################
# usage_
#
# Display usage and exit with the given code.

function usage {

    cat << EOF
${SCRIPT_NAME} -d string [-h] [-k] [-l string] [-v] THEN '-i string' OR '-g number'
  -d : Disk to write [/dev/<disk name>].
  -g : Create a Grand Unified Disk, -l is required [guadalajara or austin]!
       0: grr_a0_po and grr_k_904ec786_230218
       1: grr_a0_po_fcs and grr_k_22d3bbb4_230224
       2: same as 1, but with the SVOS kernel and eeupdate tools
       3: same as 2, but with grr_a0_po_fcs and grr_k_f5612eb5_230227
  -h : Display this wonderful help screen.
  -i : Wic image to write.
  -k : Keep temporary output instead of deleting it.
  -l : Location. [guadalajara or austin, optional for -i, required for -g]
  -v : Display the version.
EOF
    exit $1

}

##################################
# Parse the command line options #
##################################

while getopts "d:g:hi:kl:v" option ; do

    case $option in

        d)
            DISK=$OPTARG
            ;;

        g)
            GUDV=$OPTARG
            ;;

        h)
            usage 0
            ;;

        i)
            IMAGE=$OPTARG
            ;;

	k)
	    KEEP_TEMP="true"
	    ;;

        l)
            LOC=$OPTARG
            ;;

	v)
	    script_info
	    exit 0
	    ;;

        *)
            usage 1
            ;;

    esac

done

shift $(($OPTIND - 1))

##########################################
# Capture stdout and stdin in a log file #
##########################################

exec 3<&1
exec 4<&2

# Create a log file and redirect. 
TEMP=$(mktemp -d /tmp/${SCRIPT_NAME}.XXXXXXXXXXXX)
LOG=$TEMP/log
PIPE=$TEMP/pipe

if [ "$KEEP_TEMP" = "true" ]
then
    echo "--> Saving temporary files in ${TEMP}"
else
    trap "rm -rf $TEMP" EXIT
fi

mknod $PIPE p
tee <$PIPE $LOG &
exec 1>&-
exec 1>$PIPE
exec 2>&-
exec 2>$PIPE

#######################
# Do something useful #
#######################

script_info

# Make sure the user is root.

if [ "0" != "$(id -u)" ]
then
    echo "Must be run as root!"
    exit 1
fi

# Make sure a disk was specified, and that it exists.

if [ -z "$DISK" ] || [ ! -w "$DISK" ]
then
    echo "Disk must be set, exist, and be writeable."
    exit 1
fi

# Make sure no partitions on $DISK are mounted, or being used as swap.

echo "--> If $DISK is in use, unmount or swapoff..."
unuse_disk $DISK

# Check for NVMe...

PV=""
echo $DISK | grep -i nvme >/dev/null 2>&1

if [ $? -eq 0 ]
then
    PV="p"
fi

# Erase the disk.

dd if=/dev/zero of=$DISK bs=512 count=35 \
    || (echo "dd failed!" ; exit 1)
partprobe

if [ $? -ne 0 ]
then
    echo "--> Unable to erase disk... rebooting.  Try again!"
    reboot
    exit 1
fi

# Decide if this is a Grand Unified Disk, or a normal image.

if [ "$GUDV" != "" ]
then

    ####################
    # Grand Unified Disk
    ####################

    # Image locations are hard-coded, and this will only work on
    # gmwl-dcg-0008 in GDC!

    GUD_CUS=""
    GUD_INT=""
    GUD_BOOT=""
    GUD_OROOT=""
    GUD_NROOT=""
    GUD_EXTRA=""

    case $GUDV in

	0)
	    echo "Using grr_a0_po and grr_k_904ec786_230218"
	    GUD_CUS="grr_a0_po"
	    GUD_INT="grr_k_904ec786_230218"
	    ;;

	1)
	    echo "Using grr_a0_po_fcs and grr_k_22d3bbb4_230224"
	    GUD_CUS="grr_a0_po_fcs"
	    GUD_INT="grr_k_22d3bbb4_230224"
	    ;;

	2)
	    echo "Using grr_a0_po_fcs and grr_k_22d3bbb4_230224"
	    GUD_CUS="grr_a0_po_fcs"
	    GUD_INT="grr_k_22d3bbb4_230224"
	    ;;

	3)
	    echo "Using grr_a0_po_fcs and grr_k_f5612eb5_230227"
	    GUD_CUS="grr_a0_po_fcs"
	    GUD_INT="grr_k_f5612eb5_230227"
	    ;;

	*)
	    echo "Valid versions of GUD are 0 and 1"
	    exit 1
	    ;;
    esac

    case $LOC in
	"austin")
	    GUD_BOOT="/tools/AGRreleases/yocto/grr/GUD/$GUDV/boot"
	    GUD_OROOT="/tools/AGRreleases/yocto/hardknott/$GUD_CUS/axxia-grr-5.10/images/grr_a0_po_fcs_austinified.tgz"
	    GUD_NROOT="/tools/AGRreleases/yocto/grr/$GUD_INT/ink/images/grr_k_f5612eb5_230227_austinified.tgz"
	    GUD_EXTRA="/tools/AGRreleases/yocto/grr/GUD/extra"
	    GUD="/tools/AGRreleases/yocto/grr/GUD"
	    ;;
	"gdc")
	    GUD_BOOT="/home/yocto_releases/GUD/$GUDV/boot"
	    GUD_OROOT="/home/yocto_releases/$GUD_CUS/images/axxia-image-dev-intel-axxia-grr.tar.gz"
	    GUD_NROOT="/home/yocto_releases/$GUD_INT/ink/images/axxia-image-dev-intel-axxia-grr.tar.gz"
	    GUD_EXTRA="/home/yocto_releases/GUD/extra"
	    GUD="/home/yocto_releases/GUD"
	    ;;
	*)
	    echo "Valid locations are GDC and Austin!"
	    exit 1
	    ;;
    esac

    # Set up the disk.

    parted -a optimal -s $DISK -- mklabel gpt
    parted -a optimal -s $DISK -- mkpart primary fat16 0% 1G
    parted -a optimal -s $DISK -- name 1 msdos
    parted -a optimal -s $DISK -- set 1 legacy_boot on
    parted -a optimal -s $DISK -- mkpart primary ext4 1G 9G
    parted -a optimal -s $DISK -- name 2 oldroot
    parted -a optimal -s $DISK -- mkpart primary ext4 9G 17G
    parted -a optimal -s $DISK -- name 3 newroot
    parted -a optimal -s $DISK -- mkpart primary linux-swap 17G 18G
    parted -a optimal -s $DISK -- name 4 swap
    parted -a optimal -s $DISK -- mkpart primary ext4 18G 100%
    parted -a optimal -s $DISK -- name 5 extra
    unuse_disk $DISK
    mkfs.fat -F 16 ${DISK}${PV}1
    unuse_disk $DISK
    mkfs.ext4 -F ${DISK}${PV}2
    unuse_disk $DISK
    mkfs.ext4 -F ${DISK}${PV}3
    unuse_disk $DISK
    mkswap -f ${DISK}${PV}4
    unuse_disk $DISK
    mkfs.ext4 -F ${DISK}${PV}5

    # Make sure the system doesn't get carried away and start mounting things.

    unuse_disk $DISK

    # Update the kernel.

    partprobe

    # Get the PARTUUID for the 2nd and 3rd partitions.

    PU2=$(blkid ${DISK}${PV}2 | awk '{ print $NF }' | cut -d'"' -f2)
    PU3=$(blkid ${DISK}${PV}3 | awk '{ print $NF }' | cut -d'"' -f2)

    # Make a temporary mount point.

    MP=$(mktemp -d /tmp/image.sh.XXXXXXXXXX)

    # Update the msdos/efi partition.

    mount ${DISK}${PV}1 $MP
    cp -r $GUD_BOOT/* $MP
    sed -i -e "s#OLD_ROOT#PARTUUID=$PU2#" -e "s#NEW_ROOT#PARTUUID=$PU3#" \
	$MP/EFI/BOOT/grub.cfg
    umount $MP

    # Update the old root (hardknott based).

    mount ${DISK}${PV}2 $MP
    cd $MP
    tar xf $GUD_OROOT
    rm -rf lib/modules/*
    cp -r $GUD/$GUDV/root/lib/modules/* lib/modules
    # For now, disable rasdaemon -- the database gets really big!
    rm etc/rc*.d/S*rasdae*
    cd -
    umount $MP 

    # Update the new root (kirkstone based).

    mount ${DISK}${PV}3 $MP
    cd $MP
    tar xf $GUD_NROOT
    rm -rf lib/modules/*
    cp -r $GUD/$GUDV/root/lib/modules/* lib/modules
    # For now, disable rasdaemon -- the database gets really big!
    rm etc/rc*.d/S*rasdae*
    cd -
    umount $MP 

    # Update extras.

    mount ${DISK}${PV}5 $MP
    cp -r $GUD_EXTRA/* $MP
    umount $MP

    unuse_disk $DISK

else

    ##############
    # Normal Image
    ##############

    # Make sure $IMAGE exist.

    if [ -z "${IMAGE}" ] || [ ! -r "${IMAGE}" ]
    then
	echo "Image must be set, exist and be readable!"
	exit 1
    fi

    # Set up the disk.

    parted -a optimal -s $DISK -- mklabel gpt
    parted -a optimal -s $DISK -- mkpart primary fat16 0% 1G
    parted -a optimal -s $DISK -- name 1 msdos
    parted -a optimal -s $DISK -- set 1 legacy_boot on
    parted -a optimal -s $DISK -- mkpart primary linux-swap 1G 2G
    parted -a optimal -s $DISK -- name 2 swap
    parted -a optimal -s $DISK -- mkpart primary ext4 2G 100%
    parted -a optimal -s $DISK -- name 3 root
    unuse_disk $DISK
    mkfs.fat -F 16 ${DISK}${PV}1
    unuse_disk $DISK
    mkswap -f ${DISK}${PV}2
    unuse_disk $DISK
    mkfs.ext4 -F ${DISK}${PV}3
    unuse_disk $DISK

    MP=$(mktemp -d /tmp/image.sh.XXXXXXXXXX)
    ML=$(mktemp -d /tmp/image.sh.XXXXXXXXXX)
    PU=$(blkid ${DISK}${PV}3 | awk '{ print $NF }' | cut -d'"' -f2)
    SS=$(gdisk -l "${IMAGE}" | grep 'Sector size' | awk -e '{ print $4 }')
    BSS=$(gdisk -l "${IMAGE}" | grep msdos | awk -e '{ print $2 }')
    RSS=$(gdisk -l "${IMAGE}" | grep platform | awk -e '{ print $2 }')

    # Copy /boot.
    mount ${DISK}${PV}1 $MP
    mount -o loop,offset=$(($SS*$BSS)) $IMAGE $ML
    cp -r $ML/* $MP

    # Update grub.cfg.
    OPUID=$(cat $MP/EFI/BOOT/grub.cfg | grep PARTUUID | awk '{ print $3 }' | cut -d '=' -f 3)
    sed -i "s/$OPUID/$PU/" $MP/EFI/BOOT/grub.cfg

    # Done with boot.
    umount $ML
    umount $MP

    # Copy /root.
    mount ${DISK}${PV}3 $MP
    mount -o loop,offset=$(($SS*$RSS)) $IMAGE $ML
    cp -r $ML/* $MP

    if [ "$LOC" = "austin" ]
    then
	cd $MP
	/workspace/sw/jjacques/projects/austinify/austinify.sh \
	    -c grr -i sysv -n -y kirkstone
	cd -
    fi

    # For now, disable rasdaemon -- the database gets really big!
    cd $MP/etc
    rm rc*.d/S*rasdae*
    cd -

    # Done with root.
    umount $ML
    umount $MP
fi

#############################
# Restore stdout and stderr #
#############################

rm -f $PIPE
exec 1<&3 3<&-
exec 2<&4 4<&-

##############
# That's all #
##############

exit 0
