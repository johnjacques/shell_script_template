#!/usr/bin/env bash
######################################################################
#
# image.sh
#
# Image a disk, given an image (.wic).
#
######################################################################

# Export everything
set -a

# Version
VERSION=__VERSION__

# Name
SCRIPT_NAME=$(basename "${0}")

# Script directory
SCRIPT_DIR=`dirname $0`
pushd ${SCRIPT_DIR} >/dev/null 2>&1
SCRIPT_DIR=$(pwd)
popd >/dev/null 2>&1

#############
# Functions #
#############

function getdv {
    if [ -f /etc/os-release ]; then
	# freedesktop.org and systemd
	. /etc/os-release
	DISTRO=$NAME
	VER=$VERSION_ID
    elif type lsb_release >/dev/null 2>&1; then
	# linuxbase.org
	DISTRO=$(lsb_release -si)
	VER=$(lsb_release -sr)
    else
	# Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
	DISTRO=$(uname -s)
	VER=$(uname -r)
    fi

    echo "$DISTRO:$VER"
}

function script_info {
    echo "--> ${SCRIPT_NAME} version is ${VERSION}"
    echo "--> running on $(getdv)"
}

function unuse_disk {
    DISK=$1

    while read l
    do
	if [[ $l ]]
	then
	    P=$(echo $l | cut -d' ' -f 1)
	    MP=$(echo $l | cut -d' ' -f 3)
	    echo "$P is mounted as $MP, unmounting."
	    umount $MP

	    if [ $? -ne 0 ]
	    then
		echo "umount $MP failed!"
		exit 1
	    fi
	fi
    done <<< $(mount | grep $DISK)

    while read l
    do
	if [[ $l ]]
	then
	    P=$(echo $l | cut -d' ' -f1)
	    echo "$P is used as swap, turning it off."
	    swapoff $P
	fi
    done <<< $(swapon -s | egrep $DISK)
}

############
# Defaults #
############

DISK=""
GUDV=""
IMAGE=""
KEEP_TEMP="false"

######################################################################
# usage_
#
# Display usage and exit with the given code.

function usage {

    cat << EOF
${SCRIPT_NAME} -d string [-h] [-k] [-v] THEN '-i string' OR '-g number'
  -d : Disk to write [/dev/<disk name>].
  -g : Create a Grand Unified Disk.
       0: grr_a0_po and grr_k_904ec786_230218
       1: grr_a0_po_fcs and grr_k_22d3bbb4_230224
       2: same as 1, but with the SVOS kernel and eeupdate tools
       3: same as 2, but with grr_a0_po_fcs and grr_k_f5612eb5_230227
  -h : Display this wonderful help screen.
  -i : Wic image to write.
  -k : Keep temporary output instead of deleting it.
  -v : Display the version.
EOF
    exit $1

}

##################################
# Parse the command line options #
##################################

while getopts "d:g:hi:kv" option ; do

    case $option in

        d)
            DISK=$OPTARG
            ;;

        g)
            GUDV=$OPTARG
            ;;

        h)
            usage 0
            ;;

        i)
            IMAGE=$OPTARG
            ;;

	k)
	    KEEP_TEMP="true"
	    ;;

	v)
	    script_info
	    exit 0
	    ;;

        *)
            usage 1
            ;;

    esac

done

shift $(($OPTIND - 1))

##########################################
# Capture stdout and stdin in a log file #
##########################################

exec 3<&1
exec 4<&2

# Create a log file and redirect. 
TEMP=$(mktemp -d /tmp/${SCRIPT_NAME}.XXXXXXXXXXXX)
LOG=$TEMP/log
PIPE=$TEMP/pipe

if [ "$KEEP_TEMP" = "true" ]
then
    echo "--> Saving temporary files in ${TEMP}"
else
    trap "rm -rf $TEMP" EXIT
fi

mknod $PIPE p
tee <$PIPE $LOG &
exec 1>&-
exec 1>$PIPE
exec 2>&-
exec 2>$PIPE

#######################
# Do something useful #
#######################

script_info

# Make sure the user is root.

if [ "0" != "$(id -u)" ]
then
    echo "Must be run as root!"
    exit 1
fi

# Make sure a disk was specified, and that it exists.

if [ -z "$DISK" ] || [ ! -w "$DISK" ]
then
    echo "Disk must be set, exist, and be writeable."
    exit 1
fi

# Make sure no partitions on $DISK are mounted, or being used as swap.

echo "--> If $DISK is in use, unmount or swapoff..."
unuse_disk $DISK

# Decide if this is a Grand Unified Disk, or a normal image.

if [ "$GUDV" != "" ]
then

    ####################
    # Grand Unified Disk
    ####################

    # Image locations are hard-coded, and this will only work on
    # gmwl-dcg-0008 in GDC!

    GUD_CUS=""
    GUD_INT=""

    case $GUDV in

	0)
	    echo "Using grr_a0_po and grr_k_904ec786_230218"
	    GUD_CUS="grr_a0_po"
	    GUD_INT="grr_k_904ec786_230218"
	    ;;

	1)
	    echo "Using grr_a0_po_fcs and grr_k_22d3bbb4_230224"
	    GUD_CUS="grr_a0_po_fcs"
	    GUD_INT="grr_k_22d3bbb4_230224"
	    ;;

	2)
	    echo "Using grr_a0_po_fcs and grr_k_22d3bbb4_230224"
	    GUD_CUS="grr_a0_po_fcs"
	    GUD_INT="grr_k_22d3bbb4_230224"
	    ;;

	3)
	    echo "Using grr_a0_po_fcs and grr_k_f5612eb5_230227"
	    GUD_CUS="grr_a0_po_fcs"
	    GUD_INT="grr_k_f5612eb5_230227"
	    ;;

	*)
	    echo "Valid versions of GUD are 0 and 1"
	    exit 1
	    ;;
    esac

    # Set up the disk.

    parted -a optimal -s $DISK -- mklabel gpt
    parted -a optimal -s $DISK -- mkpart primary fat16 0% 1G
    parted -a optimal -s $DISK -- name 1 msdos
    parted -a optimal -s $DISK -- set 1 legacy_boot on
    parted -a optimal -s $DISK -- mkpart primary ext4 1G 9G
    parted -a optimal -s $DISK -- name 2 oldroot
    parted -a optimal -s $DISK -- mkpart primary ext4 9G 17G
    parted -a optimal -s $DISK -- name 3 newroot
    parted -a optimal -s $DISK -- mkpart primary linux-swap 17G 18G
    parted -a optimal -s $DISK -- name 4 swap
    parted -a optimal -s $DISK -- mkpart primary ext4 18G 100%
    parted -a optimal -s $DISK -- name 5 extra
    mkfs.fat -F 16 ${DISK}1
    mkfs.ext4 -F ${DISK}2
    mkfs.ext4 -F ${DISK}3
    mkswap -f ${DISK}4
    mkfs.ext4 -F ${DISK}5

    # Make sure the system doesn't get carried away and start mounting things.

    unuse_disk $DISK

    # Update the kernel.

    partprobe

    # Get the PARTUUID for the 2nd and 3rd partitions.

    PU2=$(ls -l /dev/disk/by-partuuid | grep "$(basename $DISK)2" \
	      | awk '{ print $9 }')
    PU3=$(ls -l /dev/disk/by-partuuid | grep "$(basename $DISK)3" \
	      | awk '{ print $9 }')

    # Make a temporary mount point.

    MP=$(mktemp -d /tmp/image.sh.XXXXXXXXXX)

    # Update the msdos/efi partition.

    mount ${DISK}1 $MP
    cp -r /home/yocto_releases/GUD/$GUDV/boot/* $MP
    sed -i -e "s#OLD_ROOT#PARTUUID=$PU2#" -e "s#NEW_ROOT#PARTUUID=$PU3#" \
	$MP/EFI/BOOT/grub.cfg
    umount $MP

    # Update the old root (hardknott based).

    mount ${DISK}2 $MP
    cd $MP
    tar xf /home/yocto_releases/$GUD_CUS/images/axxia-image-dev-intel-axxia-grr.tar.gz
    rm -rf lib/modules/*
    cp -r /home/yocto_releases/GUD/$GUDV/root/lib/modules/* lib/modules
    cd -
    umount $MP 

    # Update the new root (kirkstone based).

    mount ${DISK}3 $MP
    cd $MP
    tar xf /home/yocto_releases/$GUD_INT/ink/images/axxia-image-dev-intel-axxia-grr.tar.gz
    rm -rf lib/modules/*
    cp -r /home/yocto_releases/GUD/$GUDV/root/lib/modules/* lib/modules
    cd -
    umount $MP 

    # Update extras.

    mount ${DISK}5 $MP
    cp -r /home/yocto_releases/GUD/extra/* $MP
    umount $MP

else

    ##############
    # Normal Image
    ##############

    # Make sure $IMAGE exist.

    if [ -z "${IMAGE}" ] || [ ! -r "${IMAGE}" ]
    then
	echo "Image must be set, exist and be readable!"
	exit 1
    fi

    # Erase the disk.

    echo "--> Erasing $DISK..."

    dd if=/dev/zero of=$DISK bs=512 count=35 \
	|| (echo "dd failed!" ; exit 1)
    partprobe 2>/dev/null \
	|| (echo "partprobe failed!" ; exit 1)

    # Write the image.

    echo "--> Writing $IMAGE to $DISK..."

    dd bs=64k if=$IMAGE of=$DISK \
	|| (echo "dd failed!" ; exit 1)
    partprobe 2>/dev/null \
	|| (echo "partprobe failed!" ; exit 1)

    # Check/Fix the GPT partition table.
    sgdisk -e $DISK

fi

#############################
# Restore stdout and stderr #
#############################

rm -f $PIPE
exec 1<&3 3<&-
exec 2<&4 4<&-

##############
# That's all #
##############

exit 0
