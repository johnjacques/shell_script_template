#!/usr/bin/env bash
######################################################################
#
# match_deps.sh
#
# Given a dependency file, as in our Yocto meta layers, set up the
# clones in the given directory.
#
######################################################################

# Export everything
set -a

# Version
VERSION=__VERSION__

# Name
SCRIPT_NAME=$(basename "${0}")

# Script directory
SCRIPT_DIR=`dirname $0`
pushd ${SCRIPT_DIR} >/dev/null 2>&1
SCRIPT_DIR=$(pwd)
popd >/dev/null 2>&1

#############
# Functions #
#############

function getdv {
    if [ -f /etc/os-release ]; then
	# freedesktop.org and systemd
	. /etc/os-release
	DISTRO=$NAME
	VER=$VERSION_ID
    elif type lsb_release >/dev/null 2>&1; then
	# linuxbase.org
	DISTRO=$(lsb_release -si)
	VER=$(lsb_release -sr)
    else
	# Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
	DISTRO=$(uname -s)
	VER=$(uname -r)
    fi

    echo "$DISTRO:$VER"
}

function script_info {
    echo "--> ${SCRIPT_NAME} version is ${VERSION}"
    echo "--> running on $(getdv)"
}

############
# Defaults #
############

DEPS=""
ODIR=""
KEEP_TEMP="false"

######################################################################
# usage_
#
# Display usage and exit with the given code.

function usage {

    cat << EOF
${SCRIPT_NAME} -d file [-h] [-k] [-o directory] [-v]
  -d : File describing the dependencies.
  -h : Display this wonderful help screen.
  -k : Keep temporary output instead of deleting it.
  -o : Output directory for clones.  Default is the current directory.
  -v : Display the version.
EOF
    exit $1

}

##################################
# Parse the command line options #
##################################

while getopts "d:hko:v" option ; do

    case $option in

        d)
            DEPS=$OPTARG
            ;;

        h)
            usage 0
            ;;

	k)
	    KEEP_TEMP="true"
	    ;;

        o)
            ODIR=$OPTARG
            ;;

	v)
	    script_info
	    exit 0
	    ;;

        *)
            usage 1
            ;;

    esac

done

shift $(($OPTIND - 1))

##########################################
# Capture stdout and stdin in a log file #
##########################################

exec 3<&1
exec 4<&2

# Create a log file and redirect. 
TEMP=$(mktemp -d /tmp/${SCRIPT_NAME}.XXXXXXXXXXXX)
LOG=$TEMP/log
PIPE=$TEMP/pipe

if [ "$KEEP_TEMP" = "true" ]
then
    echo "--> Saving temporary files in ${TEMP}"
else
    trap "rm -rf $TEMP" EXIT
fi

mknod $PIPE p
tee <$PIPE $LOG &
exec 1>&-
exec 1>$PIPE
exec 2>&-
exec 2>$PIPE

#######################
# Do something useful #
#######################

script_info

if [ -z "${DEPS}" ]
then
    echo "--> Dependencies (-d file) is required!"
    exit 1
fi

pushd "$(dirname ${DEPS})" >/dev/null 2>&1
DEPS="$(pwd)/$(basename ${DEPS})"
popd >/dev/null 2>&1

if [ -z "${ODIR}" ]
then
    ODIR=$(pwd)
fi

if [ ! -d "${ODIR}" ]
then
    echo "--> ${ODIR} does not exist!"
    exit 1
fi

pushd "${ODIR}" >/dev/null 2>&1
## Use awk to split DEPENDENCIES into separate files.
awk 'BEGIN { RS="" } { F=sprintf("dep_%03d", NR) ; print > F ; close(F) }' \
    "${DEPS}"

rm -f dep_001

for dep in $(ls dep_*)
do
    URI="$(cat $dep | grep URI | cut -d' ' -f2)"
    NAME="$(basename $URI)"
    NAME="${NAME%.*}"
    BRANCH="$(cat $dep | grep branch | cut -d' ' -f2)"
    REV="$(cat $dep | grep revision | cut -d' ' -f2)"

    if [ -d "${NAME}" ]
    then
	pushd "${NAME}" >/dev/null 2>&1
	git fetch --all --prune >/dev/null 2>&1
	git checkout "${BRANCH}" >/dev/null 2>&1 || \
	    (echo "--> $BRANCH doesn't exist in $NAME!" ; exit 1)
	US="$(git branch -vv | grep '\*' | awk '{ print $4 }')"
	US="$(echo ${US:1:-1})"

	if [ "${US}" != "origin/${BRANCH}" ]
	then
	    echo "--> ${NAME}: ${BRANCH} is not set to sync with ${US}!"
	    exit 1
	fi

	git reset --hard "origin/${BRANCH}" >/dev/null 2>&1

	if [ $? -ne 0 ]
	then
	    echo "--> Unable to reset to origin/${BRANCH}!"
	    exit 1
	fi

	git reset --hard "${REV}" >/dev/null 2>&1

	if [ $? -ne 0 ]
	then
	    echo "--> Unable to get to ${REV}!"
	    exit 1
	fi
	popd >/dev/null 2>&1
    else
	git clone "${URI}" "${NAME}"
	pushd "${NAME}" >/dev/null 2>&1
	CURRENT_BRANCH="$(git branch | cut -d' ' -f2)"
	if [ "${CURRENT_BRANCH}" != "${BRANCH}" ]
	then
	    git checkout --track -b "${BRANCH}" origin/"${BRANCH}"
	fi
	git reset --hard "${REV}"
	popd >/dev/null 2>&1
    fi
done

rm -f dep_*
popd >/dev/null 2>&1

#############################
# Restore stdout and stderr #
#############################

rm -f $PIPE
exec 1<&3 3<&-
exec 2<&4 4<&-

##############
# That's all #
##############

exit 0
